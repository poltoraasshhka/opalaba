# Отчет по Лабораторной работе №1
>Автор: Босякова Яна Сергеевна

## Задача:
Я поняла смысл задачи так: на каком-то поле расположены закрашенные клетки(Валя, Дима и их клоны), которые необходимо соединить(нитями любви), которые лежат на клетках между Валями и Димами. Желательно сделать так, чтобы путь(нити) были как можно короче
## Выполнение:
Определяем переменные i1,i2,j1,j2. Они нам нужны **до** цикла
```c++
int i1,i2,j1,j2 = 0;
 ```
 Пробегаемся по всему массиву и считаем закрашенные клетки
 ```c++
 int count = 0
for(int i = 0; i < n;i++){
    for(int j = 0;j < m;j++){
        if(love[i][j] == -1){
            count++;
 ```
У нас есть поле(массив love[]) n на m. Пробегаемся по полю, пока не найдем две клетки равные -1(черные клетки)(назовем их Валентин и Дмитрий)
```c++
love = [n][m]
for(int i = i1; i < n;i++){
    for(int j = j1;j < m;j++){
        if(love[i][j] == -1){
            i1 = i;
            j1 = j;
            for(int k =i1; k < n;k++){
                for(int l = j1;l < m;l++){ 
                    if(love[k][l] == -1){
                        i2 = k;
                        j2 = l;
                    }
                }
            }
        }
    }
    }
 ```
 Запоминаем их координаты в уже ранее определенные переменные(love[i][j] - Валентин, love[k][l] - Дмитрий
 ```c++
 love = [n][m]
 i1 = i; j1 = j; i2 = k; j2 = l;
 ```
Теперь у нас есть две точки, с которыми мы будем работать

Начнем с первой точки(Валентина). Нам нужно добраться до Димы. Для начала нужно понять на сколько клеток Дима далек от Вали. Если же значения перменных будут < 0 => Валя находится ниже/левее

```c++
 int v = i1-i2;
 int d = j1-j2;
 
 ```

Используем добытые нами раннее данные для построения пути(любовной нити).Если же Валя находится ниже, то будем вить нить вверх, если же выше, то вниз

 Так же не стоит забывать о направлении вправо и влево(аналогично пункту раннее).Мы будем рисковать сразу же, поэтому парты, через которые будет проходить нить, будут равняться 1

 ```c++
 if(v < 0){
     if(d < 0){
        love[i1][j1 + 1]++;
        love[++i1][++j1]++;
     }
     if(d > 0){
         love[i1][j1 - 1]++;
         love[++i1][--j1]++;
     }
     else if(d == 0){
         love[++i1][j1]++;
     }
 }
 if(v > 0){
     if(d < 0){
        love[i1][j1 + 1]++;
        love[--i1][++j1]++;
     }
     if(d > 0){
         love[i1][j1 - 1]++;
         love[--i1][--j1]++;
     }
     else if(d == 0){
         love[--i1][j1]++;
     }
 }
 if(v == 0){
     if(d < 0){
         if(love[i1][j1 + 1] != -1) love[i1][++j1]++;
     }
     if(d > 0){
         if(love[i1][j1 - 1] != -1) love[i1][++j1]++;
     }
 }
 ```
Условия ветвления нити любви написаны. Осталось запихнуть это в цикл, который будет выполняться, пока Валя и Дима не будут соединены
```c++
 while(v == 0 && abs(d) != 1 || abs(v) != 1 && d == 0)
 ```
 **Hе забываем обновлять значения переменных v и d каждый раз перед проверкой**
```c++
v = i1-i2;
d = j1-j2;
 ```

Когда же из цикла выходим, то
```c++
i1 = i2;
j1 = j2;
 ```
Повторяем данный цикл, пока не закончатся все копии Дим и Валь, которые должны быть соединены

```c++
while(count > 1){
    //
    //код
    //
    count--;
}
 ```
 ## Вывод
 Конечно же, соединить Валю и Диму возможно(они всегда были соединены), и есть даже не один способ это сделать, но данный способ показался мне более практичным
